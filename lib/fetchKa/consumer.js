// Generated by CoffeeScript 1.7.1
(function() {
  var Consumer, FetchKaConsumer, kafka, log4js;

  log4js = require("log4js");

  log4js.replaceConsole();

  kafka = require("kafka-node");

  Consumer = kafka.HighLevelConsumer;

  exports.FetchKaConsumer = FetchKaConsumer = (function() {
    var InnerBuilder, LOG;

    LOG = log4js.getLogger("FetchKaConsumer");

    InnerBuilder = (function() {
      function InnerBuilder() {
        this._topics = [];
        this._options = {};
        this._options["connectStr"] = "localhost:2181";
        this._decoder = function(msg) {
          return JSON.parse(JSON.parse(msg.value));
        };
        this._validator = function(msg) {
          return msg;
        };
        this;
      }

      InnerBuilder.prototype.addTopic = function(t) {
        this._topics.push({
          topic: t
        });
        return this;
      };

      InnerBuilder.prototype.connectString = function(connectStr) {
        this._options["connectStr"] = connectStr;
        return this;
      };

      InnerBuilder.prototype.build = function() {
        var kafkaClient;
        kafkaClient = new kafka.Client(this._options["connectStr"]);
        return new FetchKaConsumer(new Consumer(kafkaClient, this._topics, this._options), this._topics);
      };

      return InnerBuilder;

    })();

    FetchKaConsumer.Builder = InnerBuilder;

    function FetchKaConsumer(_client, topics) {
      var t, _i, _len;
      this._client = _client;
      this._listeners = {};
      for (_i = 0, _len = topics.length; _i < _len; _i++) {
        t = topics[_i];
        this._listeners[t.topic] = [];
      }
      LOG.info("Listening to: ", topics);
    }

    FetchKaConsumer.prototype._onMessage = function(message) {
      var listener, parsedMessage, topic, validatedMessage, _i, _len, _ref, _results;
      topic = message.topic;
      if (topic in this._listeners) {
        LOG.trace("Received a message and forwarding it to the listeners: ", message);
        try {
          parsedMessage = this._decoder(message);
          validatedMessage = this._validator(parsedMessage);
          LOG.info(this._listeners, message);
          _ref = this._listeners[topic];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            listener = _ref[_i];
            _results.push(listener.onMessage(validatedMessage.message));
          }
          return _results;
        } catch (_error) {
          return LOG.info(message);
        }
      } else {
        return LOG.debug("Received message was for a topic that I am not following: ", message);
      }
    };

    FetchKaConsumer.prototype._onError = function(err) {
      var listener, _i, _len, _ref, _results;
      LOG.error("Error: ", err);
      _ref = this._listeners;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        _results.push(listener.onError(err));
      }
      return _results;
    };


    /*
     * Kafka returns json string and the default method of encoding a message is to
     * decode it as JSON.
     *
     * This method allows you to pass in a custom decoder, specifically if you use a 
     * custom custom data type before sending a message into Kafka
     */

    FetchKaConsumer.prototype.decoder = function(_decoder) {
      this._decoder = _decoder;
      return this;
    };


    /*
     * It is important to validate your messages as they come in, this could be to
     * prevent random messages going though your consumers/routes or to add in some
     * level of security about your messages to ensure they are valid before processing
     * them
     *
     * Your custom validator should throw an InvalidMessageException
     */

    FetchKaConsumer.prototype.validator = function(_validator) {
      this._validator = _validator;
      return this;
    };


    /*
     * Register a new listener to this consumer.
     *
     * This can beither a single handler or a router.
     */

    FetchKaConsumer.prototype.register = function(listener) {
      LOG.trace("Registering: ", listener.constructor.name);
      if (!(listener.topic in this._listeners)) {
        throw new Error("This client is not listening to: " + listener.topic);
      }
      this._listeners[listener.topic].push(listener);
      return this;
    };


    /*
     * If you need to stop a listener from receiving a message at runtime, then
     * pass the listener to this method to remove it from the listener list.
     */

    FetchKaConsumer.prototype.unregister = function(listener) {
      LOG.info("Unregistering: ", listener.name);
      this._listeners[listener.topic].filter(function(l) {
        return l !== listener;
      });
      return this;
    };


    /*
     * This starts the consumer to begin to listen to the Kafka topic it is
     * subscribed to.
     */

    FetchKaConsumer.prototype.start = function() {
      LOG.info("Starting to wait for messages");
      this._client.on("message", this._onMessage.bind(this));
      return this._client.on("error", this._onError.bind(this));
    };

    return FetchKaConsumer;

  })();

}).call(this);

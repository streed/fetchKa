// Generated by CoffeeScript 1.7.1
(function() {
  var Consumer, FetchKaConsumer, FetchKaHandler, FetchKaProducer, Producer, kafka, log4js,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  log4js = require("log4js");

  log4js.replaceConsole();

  kafka = require("kafka-node");

  Consumer = kafka.HighLevelConsumer;

  Producer = kafka.HighLevelProducer;

  exports.FetchKaConsumer = FetchKaConsumer = (function() {
    var InnerBuilder, LOG;

    LOG = log4js.getLogger("FetchKaConsumer");

    InnerBuilder = (function() {
      function InnerBuilder() {
        this._topics = [];
        this._options = {};
        this;
      }

      InnerBuilder.prototype.addTopic = function(t) {
        this._topics.push({
          topic: t
        });
        return this;
      };

      InnerBuilder.prototype.connectString = function(connectStr) {
        this._options["connectStr"] = connectStr;
        return this;
      };

      InnerBuilder.prototype.build = function() {
        var kafkaClient;
        kafkaClient = new kafka.Client;
        return new FetchKaConsumer(new Consumer(kafkaClient, this._topics, this._options), this._topics);
      };

      return InnerBuilder;

    })();

    FetchKaConsumer.Builder = InnerBuilder;

    function FetchKaConsumer(_client, topics) {
      var t, _i, _len;
      this._client = _client;
      this._listeners = {};
      for (_i = 0, _len = topics.length; _i < _len; _i++) {
        t = topics[_i];
        this._listeners[t.topic] = [];
      }
      LOG.info("Listening to: ", topics);
    }

    FetchKaConsumer.prototype._onMessage = function(message) {
      var listener, topic, _i, _len, _ref, _results;
      topic = message.topic;
      if (topic in this._listeners) {
        LOG.trace("Received a message and forwarding it to the listeners: ", message);
        try {
          message = JSON.parse(message.value);
        } catch (_error) {
          LOG.info(message);
        }
        LOG.info(this._listeners, message);
        _ref = this._listeners[topic];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          listener = _ref[_i];
          _results.push(listener.onMessage(message));
        }
        return _results;
      } else {
        return LOG.debug("Received message was for a topic that I am not following: ", message);
      }
    };

    FetchKaConsumer.prototype._onError = function(err) {
      var listener, _i, _len, _ref, _results;
      LOG.error("Error: ", err);
      _ref = this._listeners;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        _results.push(listener.onError(err));
      }
      return _results;
    };

    FetchKaConsumer.prototype.register = function(listener) {
      LOG.trace("Registering: ", listener.constructor.name);
      if (!(listener.topic in this._listeners)) {
        throw new Error("This client is not listening to: " + listener.topic);
      }
      this._listeners[listener.topic].push(listener);
      return this;
    };

    FetchKaConsumer.prototype.unregister = function(listener) {
      LOG.info("Unregistering: ", listener.name);
      this._listeners[listener.topic].filter(function(l) {
        return l !== listener;
      });
      return this;
    };

    FetchKaConsumer.prototype.start = function() {
      LOG.info("Starting to wait for messages");
      this._client.on("message", this._onMessage.bind(this));
      return this._client.on("error", this._onError.bind(this));
    };

    return FetchKaConsumer;

  })();

  exports.FetchKaHandler = FetchKaHandler = (function() {
    var InnerBuilder;

    InnerBuilder = (function() {
      function InnerBuilder() {
        this._topic = void 0;
        this._onMessage = function() {
          return null;
        };
        this._onError = function() {
          return null;
        };
      }

      InnerBuilder.prototype.setTopic = function(_topic) {
        this._topic = _topic;
        return this;
      };

      InnerBuilder.prototype.setOnMessage = function(_onMessage) {
        this._onMessage = _onMessage;
        return this;
      };

      InnerBuilder.prototype.setOnError = function(_onError) {
        this._onError = _onError;
        return this;
      };

      InnerBuilder.prototype.set = function(options) {
        if ("onMessage" in options) {
          this.setOnMessage(options.onMessage);
        }
        if ("onError" in options) {
          this.setOnError(options.onError);
        }
        if ("topic" in options) {
          this.setTopic(options.topic);
        }
        return this;
      };

      InnerBuilder.prototype.build = function() {
        return new FetchKaHandler(this._topic, this._onMessage, this._onError);
      };

      return InnerBuilder;

    })();

    FetchKaHandler.Builder = InnerBuilder;

    function FetchKaHandler(topic, onMessage, onError) {
      this.topic = topic;
      this.onMessage = onMessage;
      this.onError = onError;
    }

    return FetchKaHandler;

  })();

  exports.FetchKaProducer = FetchKaProducer = (function() {
    var InnerBuilder, LOG;

    LOG = log4js.getLogger("FetchKaProducer");

    InnerBuilder = (function() {
      function InnerBuilder() {
        this._options = {};
        this._topics = [];
      }

      InnerBuilder.prototype.connectString = function(connectStr) {
        this._options["connectStr"] = connectStr;
        return this;
      };

      InnerBuilder.prototype.addTopic = function(topic) {
        this._topics.push(topic);
        return this;
      };

      InnerBuilder.prototype.setTopics = function(_topics) {
        this._topics = _topics;
        return this;
      };

      InnerBuilder.prototype.build = function() {
        var kafkaClient;
        kafkaClient = new kafka.Client();
        if (this._topics === void 0) {
          throw new Error("Producer requires a list of valid topics.");
        }
        return new FetchKaProducer(new Producer(kafkaClient, this._options), this._topics);
      };

      return InnerBuilder;

    })();

    FetchKaProducer.Builder = InnerBuilder;

    function FetchKaProducer(_client, _topics) {
      this._client = _client;
      this._topics = _topics;
      LOG.trace("Created a new Producer that will publish messages to: ", this._topics);
      this._isReady = false;
      this;
    }

    FetchKaProducer.prototype.ready = function(cb) {
      var outer;
      LOG.trace("Connection to Kafka is ready, running the callback");
      cb.bind(this);
      outer = function() {
        this._isReady = true;
        return cb();
      };
      return this._client.on("ready", outer.bind(this));
    };

    FetchKaProducer.prototype.sendOne = function(topic, message, cb, batch) {
      if (batch == null) {
        batch = false;
      }
      if ((__indexOf.call(this._topics, topic) >= 0)) {
        LOG.trace("Sending a message to", topic, message);
        if (batch) {
          return LOG.trace("Batching upto 10 messages before sending to kafka.");
        } else {
          LOG.trace("Sending a single message to Kafka");
          return this.send([
            {
              topic: topic,
              messages: JSON.stringify({
                message: message
              })
            }
          ], cb);
        }
      } else {
        throw new Error("Topic is not in the valid list of topics: ", this._topics);
      }
    };

    FetchKaProducer.prototype.send = function(messages, cb) {
      return this._send(messages, cb);
    };

    FetchKaProducer.prototype._send = function(messages, cb) {
      var message;
      if (this._isReady) {
        LOG.info(messages);
        messages = (function() {
          var _i, _len, _ref, _results;
          _results = [];
          for (_i = 0, _len = messages.length; _i < _len; _i++) {
            message = messages[_i];
            if (_ref = message.topic, __indexOf.call(this._topics, _ref) >= 0) {
              _results.push({
                topic: message.topic,
                messages: JSON.stringify(message.messages)
              });
            }
          }
          return _results;
        }).call(this);
        LOG.trace("I am connected and we filtered out any messages that cannot be sent. So publish the remaining messages: ", messages);
        return this._client.send(messages, cb);
      } else {
        throw new Error("Producer is not ready");
      }
    };

    return FetchKaProducer;

  })();

}).call(this);

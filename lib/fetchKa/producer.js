// Generated by CoffeeScript 1.7.1
(function() {
  var FetchKaProducer, Producer, kafka, log4js,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  log4js = require("log4js");

  log4js.replaceConsole();

  kafka = require("kafka-node");

  Producer = kafka.HighLevelProducer;

  exports.FetchKaProducer = FetchKaProducer = (function() {
    var InnerBuilder, LOG;

    LOG = log4js.getLogger("FetchKaProducer");

    InnerBuilder = (function() {
      function InnerBuilder() {
        this._options = {};
        this._options["connectStr"] = "localhost:2181";
        this._topics = [];
      }

      InnerBuilder.prototype.connectString = function(connectStr) {
        this._options["connectStr"] = connectStr;
        return this;
      };

      InnerBuilder.prototype.addTopic = function(topic) {
        this._topics.push(topic);
        return this;
      };

      InnerBuilder.prototype.setTopics = function(_topics) {
        this._topics = _topics;
        return this;
      };

      InnerBuilder.prototype.build = function() {
        var kafkaClient;
        kafkaClient = new kafka.Client(this._options["connectStr"]);
        if (this._topics === void 0) {
          throw new Error("Producer requires a list of valid topics.");
        }
        return new FetchKaProducer(new Producer(kafkaClient, this._options), this._topics);
      };

      return InnerBuilder;

    })();

    FetchKaProducer.Builder = InnerBuilder;

    function FetchKaProducer(_client, _topics) {
      this._client = _client;
      this._topics = _topics;
      LOG.trace("Created a new Producer that will publish messages to: ", this._topics);
      this._isReady = false;
      this;
    }

    FetchKaProducer.prototype.ready = function(cb) {
      var outer;
      LOG.trace("Connection to Kafka is ready, running the callback");
      cb.bind(this);
      outer = function() {
        this._isReady = true;
        return cb();
      };
      return this._client.on("ready", outer.bind(this));
    };

    FetchKaProducer.prototype.sendOne = function(topic, message, cb, batch) {
      if (batch == null) {
        batch = false;
      }
      if ((__indexOf.call(this._topics, topic) >= 0)) {
        LOG.trace("Sending a message to", topic, message);
        if (batch) {
          return LOG.trace("Batching upto 10 messages before sending to kafka.");
        } else {
          LOG.trace("Sending a single message to Kafka");
          return this.send([
            {
              topic: topic,
              messages: JSON.stringify({
                message: message
              })
            }
          ], cb);
        }
      } else {
        throw new Error("Topic is not in the valid list of topics: ", this._topics);
      }
    };

    FetchKaProducer.prototype.send = function(messages, cb) {
      return this._send(messages, cb);
    };

    FetchKaProducer.prototype._send = function(messages, cb) {
      var message;
      if (this._isReady) {
        LOG.info(messages);
        messages = (function() {
          var _i, _len, _ref, _results;
          _results = [];
          for (_i = 0, _len = messages.length; _i < _len; _i++) {
            message = messages[_i];
            if (_ref = message.topic, __indexOf.call(this._topics, _ref) >= 0) {
              _results.push({
                topic: message.topic,
                messages: JSON.stringify(message.messages)
              });
            }
          }
          return _results;
        }).call(this);
        LOG.trace("I am connected and we filtered out any messages that cannot be sent. So publish the remaining messages: ", messages);
        return this._client.send(messages, cb);
      } else {
        throw new Error("Producer is not ready");
      }
    };

    return FetchKaProducer;

  })();

}).call(this);
